---
lab:
    title: 'ラボ 07:  デバイス メッセージ ルーティング'
    module: 'モジュール 4: メッセージ処理と分析'
---

# デバイス メッセージ ルーティング

## ラボ シナリオ

Contoso の経営陣は、DPS を使用した自動デバイス登録の実装に感銘を受けています。彼らは、製品のパッケージと出荷に関連するビジネス固有の問題に対する IoT ソリューションを検討し始するよう求めています。

Contoso のチーズ製造ビジネスの重要な要素は、顧客へのチーズの梱包と出荷です。コスト効率を最大化するために、Contoso はオンプレミスのパッケージング施設を運営しています。ワークフローは簡単です。パッケージは出荷のために組み立てられ、コンベヤー ベルト システムに置かれると、運ばれて、郵便箱に落とされます。成功の指標は、所定の時間内 (通常は勤務シフト) にコンベア ベルト システムから出発するパッケージの数です。

コンベア ベルト システムは、このプロセスの重要なリンクであり、パッケージが正しく配送されることを確実にするために目視で監視されています。システムには、停止、低速、高速という 3 つのオペレータ制御速度があります。当然、低速で配送される荷物の数は、高速の場合よりも少なくなります。しかし、コンベア ベルト システムの振動レベルも、低速では低くなります。さらに、高い振動レベルでは、システムの消耗が加速することが知られており、パッケージがコンベアから落ちる可能性があります。振動が過剰になった場合は、より深刻な故障を避けるために、コンベア ベルトを停止して検査を行う必要があります。

ソリューションの主な目的は、振動レベルに基づく予防メンテナンスの形態を実装することです。これを使用することで、深刻なシステムの損傷が発生する前に、問題を検出できます。 

> **注意**: **予防保全** (予測メンテナンスとも呼ばれる) は、機器が正常に動作している間に実行されるメンテナンス活動をスケジュールする設備メンテナンスプログラムです。このアプローチの目的は、多くの場合コストのかかる混乱が発生する、予期しない故障を回避することです。

異常な振動レベルを検出することは難しい場合もあります。このため、振動レベルとデータ異常のメジャーに役立つ Azure IoT ソリューションを検討しています。振動センサーは、さまざまな場所でコンベア ベルトに取り付けられ、IoT デバイスを使用して IoT ハブにテレメトリを送信します。IoT ハブは、Azure Stream Analytics と組み込みの機械学習 (ML) モデルを使用して、リアルタイムで振動異常を警告します。また、将来さらに分析を実行できるように、すべてのテレメトリ データをアーカイブする予定です。

単一の IoT デバイスからシミュレートしたテレメトリを使用して、ソリューションのプロトタイプを作成することを決定します。

振動データを現実的な方法でシミュレートするには、エンジニアの 1 人と協力して、振動の原因について少しなりとも理解しておきます。全体の振動レベルに寄与する振動の種類が、さまざまに多いことが判明しました。たとえば、ガイド ホイールが壊れたり、特に重い負荷が不適切にコンベア ベルトにかかったりすると、「力振動」が発生する可能性があります。また、システム設計の限界 (速度や重量など) を超えたときに導入できる「増加する振動」もあります。多少のサポートがあれば、振動データの表現を許容可能なものとして生み出し、異常を生成する、シミュレートされた IoT デバイスのコードを開発することができます。

次のリソースが作成されます。

![ラボ 7 アーキテクチャ](media/LAB_AK_07-architecture.png)

## このラボの内容

このラボでは、次のタスクを完了します。

* ラボの前提条件が満たされていることを確認する (必要な Azure リソースがあること)
* Azure CLI を使用して、Azure IoT Hub とデバイス ID を作成します。
* Visual Studio Code を使用して、デバイスのテレメトリを IoT Hub に送信する C# アプリを作成する
* Azure portal を使用して BLOB ストレージへのメッセージ ルートを作成する
* Azure portal を使用して Azure Stream Analytics ジョブに対する 2 番目のメッセージ ルートを作成する

## ラボの手順

### 演習 1: ラボの前提条件を確認する

このラボでは、次の Azure リソースが利用可能であることを前提としています。

| リソースの種類:  | リソース名 |
| :-- | :-- |
| リソース グループ | AZ-220-RG |
| IoT Hub | AZ-220-HUB-_{YOUR-ID}_ |
| デバイス ID | VibrationSensorId |

これらのリソースを利用できない場合は、演習 2 に進む前に、以下の手順に従って、**lab07-setup.azcli** スクリプトを実行する必要があります。スクリプト ファイルは、開発環境構成 (ラボ 3) の一部としてローカルに複製した GitHub リポジトリに含まれています。

**lab07-setup.azcli** スクリプトは、**Bash** シェル環境で実行するように記述されています。Azure Cloud Shell でこれを実行する最も簡単な方法です。

1. ブラウザーを使用して [Azure Shell](https://shell.azure.com/) を開き、このコースで使用している Azure サブスクリプションでログインします。

    Cloud Shell のストレージの設定に関するメッセージが表示された場合は、デフォルトをそのまま使用します。

1. Azure Cloud Shell が **Bash** を使用していることを確認 します。

    「Azure Cloud Shell」 ページの左上隅にあるドロップダウンは、環境を選択するために使用されます。選択されたドロップダウンの値が **Bash** であることを確認します。 

1. Azure Shell ツール バーで、「**ファイルのアップロード/ダウンロード**」 をクリックします (右から 4 番目のボタン)。

1. ドロップダウンで、「**アップロード**」 をクリックします。

1. ファイル選択ダイアログで、開発環境を構成したときにダウンロードした GitHub ラボ ファイルのフォルダーの場所に移動します。

    _ラボ 3: 開発環境の設定_:ZIP ファイルをダウンロードしてコンテンツをローカルに抽出することで、ラボ リソースを含む GitHub リポジトリを複製しました。抽出されたフォルダー構造には、次のフォルダー パスが含まれます。

    * Allfiles
      * ラボ
          * 07-デバイス メッセージ ルーティング
            * セットアップ

    lab07-setup.azcli スクリプト ファイルは、ラボ 7 のセットアップ フォルダーにあります。

1. **lab07-setup.azcli** ファイルを選択し、「**開く**」 をクリックします。   

    ファイルのアップロードが完了すると、通知が表示されます。

1. 正しいファイルが Azure Cloud Shell にアップロードされたことを確認するには、次のコマンドを入力します。

    ```bash
    ls
    ```

    `ls` コマンドを実行すると、現在のディレクトリの内容が一覧表示されます。lab07-setup.azcli ファイルが一覧表示されます。

1. セットアップ スクリプトを含むディレクトリをこのラボ用に作成し、そのディレクトリに移動するには、次の Bash コマンドを入力します。

    ```bash
    mkdir lab7
    mv lab07-setup.azcli lab7
    cd lab7
    ```

1. **lab07-setup.azcli** に実行権限があることを確認するには、次のコマンドを入力します。 

    ```bash
    chmod +x lab07-setup.azcli
    ```

1. Cloud Shell のツール バーで、lab07-setup.azcli ファイルを編集するには、「**エディターを開く**」 (右から 2 番目のボタン - **{ }**) をクリックします。

1. 「**ファイル**」 の一覧で、lab7 フォルダーを展開してスクリプト ファイルを開き、「**lab7**」 をクリックして、「**lab07-setup.azcli**」 をクリックします。     

    エディターは、**lab07-setup.azcli** ファイルの内容を表示します。

1. エディターで、割り当て済みの値 `{YOUR-ID}` と `{YOUR-LOCATION}` を更新します。

    サンプル例として、このコースの最初に作成した一意の ID 、つまり **CAH191211** に `{YOUR-ID}` を設定し、リソースにとって意味のある場所に `{YOUR-LOCATION}` を設定する必要があります。

    ```bash
    #!/bin/bash

    YourID="{YOUR-ID}"
    RGName="AZ-220-RG"
    IoTHubName="AZ-220-HUB-$YourID"

    Location="{YOUR-LOCATION}"
    ```

    > **注意**:  `{YOUR-LOCATION}` 変数は、リージョンの短い名前に設定する必要があります。次のコマンドを入力すると、使用可能な領域とその短い名前 (「**名前**」 列) の一覧を表示できます。
    >
    > ```bash
    > az account list-locations -o Table
    >
    > DisplayName           Latitude    Longitude    Name
    > --------------------  ----------  -----------  ------------------
    > East Asia             22.267      114.188      eastasia
    > Southeast Asia        1.283       103.833      southeastasia
    > Central US            41.5908     -93.6208     centralus
    > East US               37.3719     -79.8164     eastus
    > East US 2             36.6681     -78.3889     eastus2
    > ```

1. エディター画面の右上で、ファイルに加えた変更を保存してエディタを閉じるには、「**..**」 をクリックし、「**エディタを閉じる**」 をクリックします。 

    保存を求められたら、「**保存**」 をクリックすると、エディタが閉じます。 

    > **注意**:  「**CTRL+S**」 を使っていつでも保存でき、 「**CTRL+Q**」 を押してエディターを閉じます。

1. この実習ラボに必要なリソースを作成するには、次のコマンドを入力します。

    ```bash
    ./lab07-setup.azcli
    ```

    このスクリプトの実行には数分かかります。各ステップが完了すると、JSON 出力が表示されます。

    このスクリプトは、まず **AZ-220-RG** という名前のリソース グループ と **AZ-220-ハブ-{YourID}** という名前の IoT ハブを作成します。  既に存在する場合は、対応するメッセージが表示されます。次に、スクリプトにより **VibrationSensorId** の ID を持つデバイスを IoT ハブに追加し、デバイスの接続文字列を表示します。 

1. スクリプトが完了すると、デバイスの接続文字列が表示されることに注意してください。

    接続文字列は「HostName=」で始まります。

1. 接続文字列をテキスト ドキュメントにコピーし、**VibrationSensorId** デバイス用であることに注意します。 

    接続文字列を簡単に見つけることができる場所に保存すると、ラボを続ける準備が整います。

### 演習 2: 振動テレメトリのコードを記述する

コンベヤー ベルトを監視するキーは、振動テレメトリの出力です。振動は通常加速度(m/s2)として測定されますが、時には1 g = 9.81 m/s2 の g力で測定されることもあります。振動には 3 つのタイプがあります。

* 構造が振動する傾向がある周波数にすぎない、自然振動。
* 構造に影響を与えたときに発生するが、その後干渉なしに振動する、自由振動。
* 構造が何らかのストレスを受けているときに発生する強制振動。

強制振動は、私たちのコンベア ベルトにとって危険なものです。低レベルで始めたとしても、構造に途中で障害が発生するようにこの振動を構築できます。コンベヤ ベルトの操作で自由振動が発生するケースは少なくなります。ご存知のとおり、ほとんどの機械は自然振動を持っています。

構築するコード サンプルは、速度の範囲 (停止、低速、高速) で実行されるコンベア ベルトをシミュレートします。ベルトの回転が速ければ速いほど、より多くの荷物が配達されますが、振動の影響は大きくなります。ランダム化した正弦波に基づいて、自然振動を追加します。異常検出システムは、この正弦波のスパイクまたはディップを異常として誤って識別する可能性があります。次に、2つの形態の強制振動を追加します。1つ目は、振動の周期的増加の影響をします (下の画像を参照) 。そして2つ目は、増加する振動。正弦波が追加され、小さなものから始まり成長します。

このプロトタイプ フェーズ時に、コンベア ベルトにセンサー デバイス (シミュレートされた IoT デバイス) が 1 つだけあるものとします。振動データの通信に加えて、センサーも他のデータ (荷物の配送、周囲温度、および同様のメトリック) をポンプで送り出します。このラボでは、追加の値がストレージ アーカイブに送信されます。

このラボでのほぼすべてのコーディングは、この演習で完了します。C# でシミュレーター コードをビルドするのには、 Visual Studio Code を使用します。このラボの後半で、少量の SQL コーディングを完成させます。

この演習では、次の操作を行います。

* コンベア ベルトシミュレータを構築する
* 前ユニットで作成した IoT Hub にテレメトリ メッセージを送信する

#### タスク 1: テレメトリを送信するアプリを作成する

1. Visual Studio Code を開き、C# 拡張機能がインストールされていることを確認します。

    このコースのラボ 3 で開発環境を設定しますが、デバイス アプリの構築を開始する前にざっと確認しておく価値があります。 

    Visual Studio Code で C# を使用するには、[.NET Core](https://dotnet.microsoft.com/download) と [C# の拡張機能](https://marketplace.visualstudio.com/items?itemName=ms-vscode.csharp)の両方をインストールする必要があります。    上から 5 番目のボタンをクリックすると、左側のツール バーを使用して Visual Studio Code 拡張機能のウィンドウを開くことができます。

1. 「**ターミナル**」 メニューで、「**新しいターミナル**」 をクリックします。

    コマンド プロンプトの一部として表示されたディレクトリ パスに注目してください。以前のラボ プロジェクトのフォルダー構造内で、このプロジェクトのビルドを開始したくありません。
  
1. ターミナル コマンド プロンプトで、"vibrationdevice" という名前のディレクトリを作成して現在のディレクトリをそのディレクトリに変更するには、次のコマンドを入力します。

   ```bash
   mkdir vibrationdevice
   cd vibrationdevice
   ```

1. 新しい .NET コンソール アプリケーションを作成します。次のコマンドを入力してください。

    ```bash
    dotnet new console
    ```

    このコマンドを実行すると、プロジェクト ファイルと共に、フォルダに **Program.cs** ファイルが作成されます。 

1. デバイス アプリに必要なコード ライブラリをインストールするには、次のコマンドを入力します。

    ```bash
    dotnet add package Microsoft.Azure.Devices.Client
    dotnet add package Newtonsoft.Json
    ```

    次のタスクでは、シミュレートされたデバイス アプリをビルドしてテストします。

#### タスク 2: テレメトリを送信するコードを追加する

このタスクで構築するシミュレートされたデバイス アプリは、コンベア ベルトを監視している IoT デバイスをシミュレートします。アプリは、センサー信号をシミュレートして 2 秒ごとに振動センサー データを報告します。

1. Visual Studio Code の 「**ファイル**」 メニューの 「**フォルダを開く**」 をクリックします。   

    ターミナル コマンド プロンプト内にリストされているフォルダ パスを使用して、プロジェクト フォルダを検索します。
  
1. 「フォルダを開く」 ダイアログで、ターミナル コマンド プロンプト内に表示されるディレクトリ パスに移動し、**vibrationdevice**、「**フォルダーの選択**」 の順にクリックします。

    必要なアセットを読み込むよう求められたら、「**はい**」 をクリックします。

    Visual Studio Code Explorer ペインが開くはずです。そうでない場合は、左側のツールバーを使用してエクスプローラーのウィンドウを開きます。ツール バーのボタンの上にマウス ポインタを置くと、ボタン名を表示できます。

1. エクスプローラー ウィンドウで、**Program.cs** をクリックします。

1. コード エディター ビューで、Program.cs ファイルの既定のコンテンツを削除します。

    既定のコンテンツは、前のタスクで `dotnet new console` コマンドを実行したときに作成されました。

1. シミュレートされたデバイスのコードを作成するには、空の Program.cs ファイルに次のコードを貼り付けます。

    ```csharp
    // Copyright (c) Microsoft.All rights reserved.
    // MITライセンスの下でライセンスされています。ライセンス情報の全容については、プロジェクト ルートのライセンス ファイルをご覧ください。
    using System;
    using Microsoft.Azure.Devices.Client;
    using Newtonsoft.Json;
    using System.Text;
    using System.Threading.Tasks;

    namespace vibration_device
    {
        class SimulatedDevice
        {
            // Telemetry globals.
            private const int intervalInMilliseconds = 2000;                                 // wait 関数で必要な時間間隔。
            private static readonly int intervalInSeconds = intervalInMilliseconds / 1000;   // 秒単位の時間間隔。

            // コンベアベルト グローバル。
            enum SpeedEnum
            {
                stopped,
                slow,
                fast
            }
            private static int packageCount = 0;                                        // コンベア ベルトから出るパッケージの数。
            private static SpeedEnum beltSpeed = SpeedEnum.stopped;                     // コンベア ベルトをの初期状態。
            private static readonly double slowPackagesPerSecond = 1;                   // 低速で完了したパッケージ / 秒あたり
            private static readonly double fastPackagesPerSecond = 2;                   // Packages completed at fast speed/ per second
            private static double beltStoppedSeconds = 0;                               // ベルトが停止した時刻。
            private static double temperature = 60;                                     // 施設の周囲温度
            private static double seconds = 0;                                          // タイムコンベア ベルトが動いてる時間。

            // 振動グローバル
            private static double forcedSeconds = 0;                                    // 強制振動が始まってからの時間。
            private static double increasingSeconds = 0; 				// 振動の増加が始まってからの時間
            private static double naturalConstant;      				// 固有振動の強さを特定する定数
            private static double forcedConstant = 0;      				// 強制振動の強さを特定する定数
            private static double increasingConstant = 0;				// 増加する振動の強さを特定する定数

            // IoT Hub グローバル変数
            private static DeviceClient s_deviceClient;

            // IoT ハブでデバイスを認証するためのデバイス接続文字列。
            private readonly static string s_deviceConnectionString = "<your device connection string>";

            private static void colorMessage(string text, ConsoleColor clr)
            {
                Console.ForegroundColor = clr;
                Console.WriteLine(text);
                Console.ResetColor();
            }
            private static void greenMessage(string text)
            {
                colorMessage(text, ConsoleColor.Green);
            }

            private static void redMessage(string text)
            {
                colorMessage(text, ConsoleColor.Red);
            }

            // シミュレーションされたテレメトリを送信する非同期メソッド。
            private static async void SendDeviceToCloudMessagesAsync(Random rand)
            {
                // コンベアベルトの振動テレメトリをシミュレートする
                ダブル振動;

                while (true)
                {
                    // ベルト速度をランダムに調整する
                    スイッチ (ベルトスピード)
                    {
                        case SpeedEnum.fast:
                            if (rand.NextDouble() < 0.01)
                            {
                                beltSpeed = SpeedEnum.stopped;
                            }
                            if (rand.NextDouble() > 0.95)
                            {
                                beltSpeed = SpeedEnum.slow;
                            }
                            break;

                        case SpeedEnum.slow:
                            if (rand.NextDouble() < 0.01)
                            {
                                beltSpeed = SpeedEnum.stopped;
                            }
                            if (rand.NextDouble() > 0.95)
                            {
                                beltSpeed = SpeedEnum.fast;
                            }
                            break;

                        case SpeedEnum.stopped:
                            if (rand.NextDouble() > 0.75)
                            {
                                beltSpeed = SpeedEnum.slow;
                            }
                            break;
                    }

                    // 振動レベルを設定する
                    if (beltSpeed == SpeedEnum.stopped)
                    {
                        // ベルトが停止すると、振動はすべて停止します。
                        forcedConstant = 0;
                        increasingConstant = 0;
                        vibration = 0;

                        // 警告を送信する必要がある場合に備えて、ベルトが停止した時間を記録する
                        ベルト停止秒 += 間隔イン秒;
                    }
                    else
                    {
                        // コンベアベルトが動いています。
                        beltStoppedSeconds = 0;

                        // 不要な振動のランダムな開始を確認します。

                        // 強制振動を確認します。
                        if (forcedConstant == 0)
                        {
                            if (rand.NextDouble() < 0.1)
                            {
                                // 強制振動が開始します。
                                forcedConstant = 1 + 6 * rand.NextDouble();             // 1 から 7 の間の数字です。
                                if (beltSpeed == SpeedEnum.slow)
                                    forcedConstant /= 2;                                // 速度が遅くなると振動がより少なくなります。
                                forcedSeconds = 0;
                                redMessage($"Forced vibration starting with severity: {Math.Round(forcedConstant, 2)}");
                            }
                        }
                        else
                        {
                            if (rand.NextDouble() > 0.99)
                            {
                                forcedConstant = 0;
                                greenMessage("Forced vibration stopped");
                            }
                            else
                            {
                                redMessage($"Forced vibration: {Math.Round (forcedConstant, 1)} は次の時点で開始される: {DateTime.Now.ToShortTimeString()}");
                            }
                        }

                        // 振動の増加を確認します。
                        if (increasingConstant == 0)
                        {
                            if (rand.NextDouble() < 0.05)
                            {
                                // 振動の増加が始まります。
                                increasingConstant = 100 + 100 * rand.NextDouble();     // 100 から 200 の間の数字です。
                                if (beltSpeed == SpeedEnum.slow)
                                    increasingConstant *= 2;                            // 速度が遅くなると期間がより長くなります。
                                increasingSeconds = 0;
                                redMessage($"Increasing vibration starting with severity: {Math.Round(increasingConstant, 2)}");
                            }
                        }
                        else
                        {
                            if (rand.NextDouble() > 0.99)
                            {
                                increasingConstant = 0;
                                greenMessage("Increasing vibration stopped");
                            }
                            else
                            {
                                redMessage($"Increasing vibration: {Math.Round(increasingConstant, 1)} started at: {DateTime.Now.ToShortTimeString()}");
                            }
                        }

                        // 固有振動から始まる振動を適用します。
                        vibration = naturalConstant * Math.Sin(seconds);

                        if (forcedConstant > 0)
                        {
                            // 強制振動を追加します。
                            vibration += forcedConstant * Math.Sin(0.75 * forcedSeconds) * Math.Sin(10 * forcedSeconds);
                            forcedSeconds += intervalInSeconds;
                        }

                        if (increasingConstant > 0)
                        {
                            // 振動の増加を追加します。
                            vibration += (increasingSeconds / increasingConstant) * Math.Sin(increasingSeconds);
                            increasingSeconds += intervalInSeconds;
                        }
                    }

                    // コンベア ベルト アプリが起動してから、時間を増やします。
                    seconds += intervalInSeconds;

                    // 作業を終えたパッケージを数えます。
                    switch (beltSpeed)
                    {
                        case SpeedEnum.fast:
                            packageCount += (int)(fastPackagesPerSecond * intervalInSeconds);
                            break;

                        case SpeedEnum.slow:
                            packageCount += (int)(slowPackagesPerSecond * intervalInSeconds);
                            break;

                        case SpeedEnum.stopped:
                            // パッケージはありません!
                            break;
                    }

                    // ランダムに周囲温度を変化させます。
                    temperature += rand.NextDouble() - 0.5d;

                    // 次のように 2 つのメッセージを作成します。
                    // 1.振動テレメトリのみ、Azure Stream Analytics にルーティングされます。
                    // 2.ログ情報が、Azure ストレージ アカウントにルーティングされます。

                    // テレメトリの JSON メッセージを作成します。
                    var telemetryDataPoint = new
                    {
                        vibration = Math.Round(vibration, 2),
                    };
                    var telemetryMessageString = JsonConvert.SerializeObject(telemetryDataPoint);
                    var telemetryMessage = new Message(Encoding.ASCII.GetBytes(telemetryMessageString));

                    // メッセージにカスタム アプリケーション プロパティを追加.これはメッセージをルーティングするために使用されます。
                    テレメトリメッセージ.プロパティ.追加(「センサーID」、"VSTel")。

                    // ベルトが5秒より長く停止した場合は、警告を送信します。
                    telemetryMessage.Properties.Add("beltAlert", (beltStoppedSeconds > 5) ? "true" : "false");

                    Console.WriteLine($"Telemetry data: {telemetryMessageString}");

                    // テレメトリ メッセージを送信します。
                    await s_deviceClient.SendEventAsync(telemetryMessage);
                    greenMessage($"Telemetry sent {DateTime.Now.ToShortTimeString()}");

                    // ログ記録 JSON メッセージを作成する
                    var loggingDataPoint = new
                    {
                        vibration = Math.Round(vibration, 2),
                        packages = packageCount,
                        speed = beltSpeed.ToString(),
                        temp = Math.Round(temperature, 2),
                    };
                    var loggingMessageString = JsonConvert.SerializeObject(loggingDataPoint);
                    var loggingMessage = new Message(Encoding.ASCII.GetBytes(loggingMessageString));

                    // メッセージにカスタム アプリケーション プロパティを追加.これはメッセージをルーティングするために使用されます。
                    loggingMessage.Properties.Add("sensorID", "VSLog");

                    // ベルトが 5 秒以上停止した場合に警告を送信します。
                    loggingMessage.Properties.Add("beltAlert", (beltStoppedSeconds > 5) ? "true" : "false");

                    Console.WriteLine($"Log data: {loggingMessageString}");

                    // ログ メッセージを送信します。
                    await s_deviceClient.SendEventAsync(loggingMessage);
                    greenMessage("Log data sent\n");

                    await Task.Delay(intervalInMilliseconds);
                }
            }

            private static void Main(string[] args)
            {
                Random rand = new Random();
                colorMessage("Vibration sensor device app.\n", ConsoleColor.Yellow);

                // MQTT プロトコルを使用して IoT ハブに接続します。
                s_deviceClient = DeviceClient.CreateFromConnectionString(s_deviceConnectionString, TransportType.Mqtt);

                // 通常の振動レベルの定数として、2 から 4 の間の数値を作成します。
                naturalConstant = 2 + 2 * rand.NextDouble();

                SendDeviceToCloudMessagesAsync(rand);
                Console.ReadLine();
            }
        }
    }
    ```

1. 少し時間をかけてコードについてレビューしてください。

    > **重要:** 少し時間をかけて、コード内のコメントを一読します。IoT メッセージについて学習するためのコードの中でも最も重要なセクションは、「2 つのメッセージを作成する:」というコメントから始まります。また、コンベア ベルトの振動レベルを定義するために使用される数学が (このラボの初めのシナリオの説明に記載されている)、どのようにコードの中に入り込んでいるかを確認することに興味が湧くかもしれません。

1. `<your device connection string>` (44 行目) を、前の演習中に保存されたデバイスの接続文字列に置き換えます。

    > **注意**: これは、このコードに対して行う必要がある唯一の変更です。

1. **Program.cs** ファイルを保存します。

    > **注意**:  このコードは、ラボ 7 の `/Starter` フォルダーでも使用できます。Starter フォルダのコードを使用する場合は、忘れずに `<your device connection string>` を置き換えてください。

#### タスク 3: テレメトリを送信するコードをテストする

1. ターミナルでアプリを実行するには、次のコマンドを入力します。

    ```bash
    dotnet run
    ```

   このコマンドは、 現在のフォルダー内の **Program.cs** ファイルを実行します。

1. 次のようなコンソール出力が表示されます。

    ```
    Vibration sensor device app.

    Telemetry data: {"vibration":0.0}
    Telemetry sent 10:29 AM
    Log data: {"vibration":0.0,"packages":0,"speed":"stopped","temp":60.22}
    Log data sent

    Telemetry data: {"vibration":0.0}
    Telemetry sent 10:29 AM
    Log data: {"vibration":0.0,"packages":0,"speed":"stopped","temp":59.78}
    Log data sent
    ```

    > **注意**:  ターミナルウィンドウでは、緑色のテキストは正常に機能していることを示し、赤色のテキストは問題が発生している場合に使用されます。エラー メッセージが表示された場合は、まずデバイスの接続文字列を確認します。

1. しばらくの間テレメトリを見て、予想される範囲で振動していることを確認します。

1. 次のタスクのために、このアプリを実行したままにします。

    次のタスクに進めない場合は、ターミナルウィンドウで**Ctrl-C**を入力してアプリを停止できます。`dotnet run` コマンドを使用すれば、後で再起動できます。

#### タスク 4: IoT Hub がテレメトリを受信していることを確認する

このタスクでは、Azure portal を使用して、IoT Hub がテレメトリを受信していることを確認します。

1. [Azure portal](https://portal.azure.com) を開きます。

1. ダッシュボードの **AZ-220-RG** リソース グループ タイルで、「**AZ-220-HUB-_{YourID}_**」 をクリックします。 

1. 「**概要**」 ウィンドウで、下にスクロールしてメトリック タイルを表示します。 

1. 「**最後のデータを表示**」 に隣接した時間の範囲を 1 時間に変更します。  

    「**デバイスからクラウドへのメッセージ**」 タイルでは、いくつかの現在のアクティビティがプロットされている必要があります。  アクティビティが表示されていない場合は、多少の待ち時間があるので、しばらくお待ちください。

    デバイスによりテレメトリが送信されると、ハブによりテレメトリが受信されるので、次の手順はメッセージを正しいエンドポイントにルーティングすることです。

### 演習 3: Azure BLOB ストレージにメッセージ ルートを作成する

振動監視システムのアーキテクチャでは、データをアーカイブする保管場所と、より迅速な分析用の場所となる 2 つの目的地にデータが送信される必要があります。Azure IoT は、*メッセージ ルーティング*を通じて、適切なサービスにデータを移動させる優れた方法を提供します。 

シナリオでは、2 つのルートを作成する必要があります。

* 最初のルートは、データをアーカイブするためのストレージです
* 2 番目のルートは、異常検出のためにイベント ハブになる

メッセージ ルートは一度に 1 つずつ構築およびテストするのが最善であるため、この演習ではストレージ ルートに焦点を当てます。このルートを「ログ」ルートと呼びます。これには、Azure リソースの作成のいくつかのレベルを掘り下げることが含まれます。このルートを構築するために必要なすべての機能は、Azure portal で使用できます。

ストレージ ルートをシンプルに保ち、Azure BLOB Storage を使用します (ただし、Data Lake Storage も利用できます)。メッセージ ルーティングの重要な機能は、受信データのフィルター処理です。SQL で書かれたフィルターは、特定の条件が満たされた場合にのみ、ルートを下に出力します。

データをフィルターする最も簡単な方法の 1 つは、メッセージ プロパティで、そのため、次の2行をコードに追加しました。

```csharp
...
telemetryMessage.Properties.Add("sensorID", "VSTel");
...
loggingMessage.Properties.Add("sensorID", "VSLog");
```

メッセージルートに組み込まれた SQL クエリは、`sensorID` 値をテストできます。

この演習では、ログ記録ルートを作成してテストします。

#### タスク 1: ログ メッセージを Azure ストレージにルーティングする

1. [Azure portal](https://portal.azure.com/) で、IoT ハブの 「**概要**」 ウィンドウが開いていることを確認します、

1. 左側のメニューの 「**メッセージング**」 の下で、「**メッセージ ルーティング**」 をクリックします。   

1. 「**メッセージ ルーティング**」 ウィンドウで、「**ルート**」 タブが選択されていることを確認します。   

1. 最初のルートを追加するには、「**追加**」 をクリックします。

    「**ルートの追加**」 ブレードが表示されます。 

1. 「**ルートの追加**」 ブレードの 「**名前**」 に `vibrationLoggingRoute` と入力します。   

1. 「**エンドポイント**」 の右側の 「**エンドポイントの追加**」 をクリックし、ドロップダウン リストで 「**ストレージ**」 をクリックします。     

    「**ストレージ エンドポイントの追加**」 ブレードが表示されます。 

1. 「**エンドポイント名**」 に `vibrationLogEndpoint` と入力します。 

1. ストレージを作成してコンテナーを選択するには、「**コンテナーの選択**」 をクリックします。 

    Azure サブスクリプションに既に存在するストレージ アカウントの一覧が表示されます。この時点で既存のストレージ アカウントとコンテナーを選択できますが、このラボでは新しいストレージ アカウントとコンテナーを作成します。

1. 新しいストレージ アカウントを作成するには、「**ストレージ アカウント**」 をクリックします。 

    「**ストレージの作成**」 ウィンドウが表示されます。 

1. 「**ストレージの作成**」 ウィンドウの 「**名前**」 に、「**vibrationstore**」と入力すると、イニシャルと今日の日付「**vibrationstorecah191211**」でアペンドされます。

    > **注意**:  このフィールドには、小文字と数字のみを含めることができ、3 ~ 24 文字で、一意である必要があります。

1. 「**アカウントの種類**」 の一覧で、**StorageV2 (汎用 V2)** を選択します。

1. 「**パフォーマンス**」 で 「**標準**」 が選択されていることを確認します。   

    これにより、全体的なパフォーマンスを犠牲にして、コストを抑えることができます。

1. 「**レプリケーション**」 で、「**ローカル冗長ストレージ (LRS)**」 が選択されていることを確認します。

    これにより、ディザスター リカバリーのリスク軽減を犠牲にして、コストを抑えることができます。運用環境では、ソリューションにはより堅牢なレプリケーション戦略が必要になる場合があります。

1. 「**場所**」 で、このコースの演習で使用している地域を選択します。

1. ストレージ アカウントを作成するには、「**OK**」 をクリックします。 

1. 要求が検証され、ストレージ アカウントのデプロイが完了するまで待ちます。

    検証と作成には 1 分から 2 分かかることがあります。

    完了すると、「**ストレージ アカウントの作成**」 ウィンドウが閉じ、「**ストレージ アカウント**」 ブレードが表示されます。作成したストレージ アカウントを表示するように、「ストレージ アカウント」 ブレードが更新されている必要があります。

1. 「**vibrationstore**」を検索し、作成したストレージ アカウントを選択します。 

   「**コンテナー**」 ブレードが表示されます。これは新しいストレージ アカウントであるため、一覧表示するコンテナーはありません。

1. コンテナーを作成するには、「**コンテナー**」 をクリックします。 

    「**新しいコンテナー**」 ポップアップが表示されます。 

1. 「**新しいコンテナー**」 ポップアップで、「**名前**」 に 「**vibrationcontainer**」 と入力します

   この場合も、小文字と数字のみが受け入れられます。

1. 「**パブリック アクセス レベル**」 で 「**プライベート (匿名アクセスなし)**」 が選択されていることを確認します。   

1. コンテナーを作成するには 、「**OK**」  をクリックします。 

    しばらくすると、コンテナーの **リース状態** に 「**利用可能**」 と表示されます。

1. ソリューションのコンテナーを選択するには、「**vibrationcontainer**」 をクリックし、「**選択**」 をクリックします。   

    「**ストレージ エンドポイントの追加**」 ウィンドウに戻ります。  **Azure Storage コンテナー**が、作成したストレージ アカウントとコンテナーの URL に設定されていることに注意してください。

1. 「**バッチの頻度**」 ウィンドウと **「チャンク サイズ」 ウィンドウ** は既定値の **100**のままにします。

1. 「**エンコード**」 で、2 つのオプションがあり、**AVRO** が選択されていることに注意してください。   

    > **注意**:  既定では、IoT Hub は Avro 形式でコンテンツを書き込み、メッセージ本文プロパティとメッセージ プロパティの両方があります。Avro 形式は、他のエンドポイントには使用されません。Avro 形式はデータとメッセージの保存に適していますが、データのクエリに使用するのは難しいことです。これに対して、JSON 形式または CSV 形式の方が、データのクエリがはるかに簡単です。IoT ハブでは、データの JSON と AVRO での Blob Storage へのデータの書き込みがサポートされるようになりました。

1. 「**ファイル名の形式**」 フィールドで指定した値を調べます。

    「**ファイル名の形式**」 フィールドは、ストレージ内のファイルにデータを書き込むために使用するパターンを指定します。  ファイルが作成されると、さまざまなトークンが値に置き換えられます。

1. ペインの下部で、エンドポイントを作成するには、「**作成**」 をクリックします。 

    検証と作成には少し時間がかかります。完了したら、「**ルートの追加**」 ブレードに戻ります。

1. 「**ルートの追加**」 ブレードの 「**データソース**」 で、「**デバイス テレメトリ メッセージ**」 が選択されていることを確認します。     

1. **「ルートを有効にする」** で、**「有効」** が選択されていることを確認します。

1. 「**ルーティング クエリ**」 の下で、次のクエリに **true** を置き換えます。 

    ```sql
    sensorID = "VSLog"
    ```

    これにより、メッセージは `sensorID = "VSLog"` の場合にのみこのルートに従います。

1. このルートを保存するには、「**保存**」 をクリックします。 

    成功メッセージを待ちます。完了すると、ルートが 「**メッセージ ルーティング**」 ブレードに表示されます。

1. Azure portal ダッシュボードに戻ります。

次の手順では、ログ記録ルートが機能していることを確認します。

### 演習 4: ログ ルート Azure Stream Analytics ジョブ

ログ記録ルートが期待どおりに動作していることを確認するために、ログ 記録メッセージを Blob Storage にルーティングする Stream Analytics ジョブを作成し、Azure Portal の Storage Explorer を使用して検証できます。

これにより、ルートに次の設定が含まれていることを確認できます。

* **名前** - vibrationLoggingRoute
* **データ ソース** - DeviceMessages
* **ルーティング クエリ** - sensorID = "VSLog"
* **エンドポイント** - vibrationLogEndpoint
* **有効化** -  true

> **注意**: このラボでは、奇妙に思えるかもしれませんが、データをストレージにルーティングし、Azure Stream Analytics を使用してデータをストレージにも送信しています。作成シナリオでは、両方のパスを長期的には使用しません。代わりに、ここで作成している 2 番目のパスが存在しない可能性があります。ここでは、ラボ環境でルーティングが期待どおりに機能していることを検証し、Azure Stream Analytics の簡単な実装を示す方法として使用しています。

#### タスク 1: Streaming Analytics ジョブを作成する

1. Azure portal メニューで、「**リソースの作成**」 をクリックします。

1. 「**新規**」 ブレードの 「**マーケットプレースの検索**」 ボックスに 「**Stream Analytics ジョブ**」 と入力し、「**Stream Analytics ジョブ**」 をクリックします。       

1. 「**Stream Analytics ジョブ**」 ブレードで、「**作成**」 をクリックします。

    「**新しい Stream Analytics ジョブ**」 ウィンドウが表示されます。 

1. 「**新しい Stream Analytics ジョブ**」 ウィンドウの 「**名前**」 の下に `vibrationJob` と入力します。

1. 「**サブスクリプション**」 で、ラボで使用しているサブスクリプションを選択します。

1. 「**リソース グループ**」 で 「**AZ-220-RG**」 を選択します。   

1. 「**場所**」 で、すべてのラボ作業に使用するリージョンを選択します。 

1. 「**ホスティング環境**」 で 「**クラウド**」 を選択します。   

    エッジ ホスティングについては、コースの後半で説明します。

1. 「**ストリーミング ユニット**」 で、数値を **3** から **1** に減ら します。     

    このラボでは 3 ユニットは必要ありません。これによりコストが削減されます。

1. Stream Analytics ジョブを作成するには、**作成**をクリックします。

1. 「**デプロイの成功**」 メッセージを待ってから、新しいリソースを開きます。 

    > **ヒント:** 新しいリソースに移動するメッセージが見つからない場合、またはいつでもリソースを見つける必要がある場合は、「**ホーム/すべてのリソース**」を選択します。リソースの一覧に表示するため、リソース名を入力します。

1. お手数ですが、新しい Stream Analytics ジョブを調べてください。

    空のジョブがあり、入力または出力が表示されておらず、スケルトン クエリが存在することに注意してください。次に、これらのエントリを作成します。

1. 入力を作成するには、左側のナビゲーションの 「**ジョブ トポロジ**」 で 「**入力**」 をクリックします。   

    「**入力**」 ウィンドウが表示されます。 

1. 「**入力**」 ウィンドウで、「**ストリーム入力の追加**」 をクリックし、ドロップダウン リストから 「**IoT Hub**」 を選択します。

    「**新しい入力**」 ウィンドウが表示されます。 

1. 「**新しい入力**」 ウィンドウの 「**入力エイリアス**」 に `vibrationInput` と入力します。

1. 「**サブスクリプションから IoT Hub を選択**」 が選択されていることを確認します。

1. 「**サブスクリプション**」 で、以前に IoT Hub の作成に使用したサブスクリプションが選択されていることを確認します。

1. 「**IoTHub**」 で、コース ラボの最初に作成した IoT Hub **AZ-220-HUB-_{YourID}_** を選択します。

1. 「**エンドポイント**」 で 、「**メッセージング**」 が選択されていることを確認します。

1. 「**共有アクセス ポリシー名**」 で **iothubowner** が選択されていることを確認します。   

    > **注意**:  **共有アクセス ポリシー キー**は読み取り専用で実装されます。 

1. 「**コンシューマー グループ**」 で **$Default** が選択されていることを確認します。

1. **「イベントのシリアル化形式」** で **「JSON」** が選択されていることを確認します。

1. **「エンコード」** で、**「UTF-8」** が選択されていることを確認します。

    フィールドの一部を表示させるために、下にスクロールする必要がある場合があります。

1. 「**イベントの圧縮タイプ**」 で 「**なし**」 が選択されていることを確認します。   

1. 新しい入力を保存するには、**「保存」** をクリックし、入力が作成されるまで待ちます。

    **入力**リストが更新されて、新しい入力が表示されるはずです。

1. 出力を作成するには、左側のナビゲーションの 「**ジョブ トポロジ**」 の下で、「**出力**」 をクリックします。   

    **「出力」** ウィンドウが表示されます。

1. 「**出力**」 ウィンドウで 「**追加**」 をクリックし、ドロップダウン リストから 「**BLOB ストレージ/Data Lake Storage Gen2**」 を選択します。     

    「**新規出力**」 ウィンドウが表示されます。 

1. 「**新しい出力**」 ウィンドウの 「**出力エイリアス**」 の下に、`vibrationOutput` と入力します。   

1. 「**サブスクリプションからストレージを選択**」 が選択されていることを確認します。 

1. 「**サブスクリプション**」 で、このラボで使用しているサブスクリプションを選択します。

1. 「**ストレージ アカウント**」 で、以前に作成したストレージ アカウント  (**vibrationstore** とイニシャルと日付) を選択します。   

    > **注意**:  **ストレージ アカウント キー**は自動的に設定され、読み取り専用になります。 

1. 「**コンテナー**」 で、「**既存の使用**」 が選択され、ドロップダウン リストから 「**vibrationcontainer**」 が選択されていることを確認します。     

1. **パス パターン**は空白のままにします。 

1. 「**日付の形式**」 と 「**時刻の形式**」 は既定値のままにします。   

1. **「イベントのシリアル化形式」** で **「JSON」** が選択されていることを確認します。

1. **「エンコード」** で、**「UTF-8」** が選択されていることを確認します。

1. 「**形式**」 で、「**線区切り**」 が選択されていることを確認します。   

    > **注意**:  この設定では、各レコードを各行に JSON オブジェクトとして格納し、全体として取得すると、ファイルが無効な JSON レコードになります。もう 1 つのオプション 「**配列**」 は、各レコードが配列内の項目である JSON 配列として文書全体がフォーマットされることを保証します。  これにより、ファイル全体を有効な JSON として解析できます。

1. **最小行は**空白のままにします。

1. 「**最大時間**」 で、「**時間** と **分**」 を空白のままにします。

1. 「**認証モード**」 で 「**接続文字列**」 が選択されていることを確認します。

1. 出力を作成するには、「**保存**」 をクリックし、出力が作成されるのを待ちます。 

    **出力**リストが新しい出力で更新されます。

1. クエリを編集するには、左側のナビゲーションの 「**ジョブ トポロジ**」 で 「**クエリ**」 をクリック します。

1. クエリ編集ウィンドウで、既存のクエリを以下のクエリに置き換えます。

    ```sql
    SELECT
        *
    INTO
        vibrationOutput
    FROM
        vibrationInput
    ```

1. 編集ペインの真上にある 「**クエリの保存**」 をクリックします。 

1. 左側のナビゲーションで、「**概要**」 をクリックします。

#### タスク 2: ログ ルートをテストする

さて次は、楽しい部分になります。デバイス アプリによって送り出されるテレメトリは、ルートに沿ってストレージ コンテナーの中に入り込みますか。

1. Visual Studio Code で作成したデバイス アプリが、依然として実行されていることを確認します。 

    そうでない場合は、`dotnet run` を使用して Visual Studio Code ターミナルで実行します。

1. Stream Analytics ジョブの 「**概要**」 ウィンドウで、「**開始**」 をクリックします。   

1. 「**ジョブの開始**」 ウィンドウで、「**ジョブ出力の開始時刻**」 を 「**現在**」 のままにし、「**開始**」 をクリック します。       

    ジョブが開始するまでに、すこし時間がかかります。

1. Azure portal メニューで、**「ダッシュボード」** をクリックします。

1. リソース グループ タイルで、 **vibrationstore** (およびイニシャルと日付) ストレージ アカウントを選択します。

    ストレージ アカウントが表示されない場合は、 リソース グループ タイルの上部にある 「**更新**」 ボタンを使用します。

1. ストレージ アカウントの 「**概要**」 ウィンドウで、「**監視**」 セクションが表示されるまで下にスクロールします。

1. 「**監視**」 で、「**最後のデータを表示**」 の横にある時間の範囲を **1 時間** に変更します。

    グラフにアクティビティが表示されます。

1. 左側のナビゲーション メニューで、「**ストレージ エクスプローラー (プレビュー)**」 をクリックします。

    ストレージ エクスプローラーを使用して、すべてのデータがストレージ アカウントに到達していることを再確認できます。 

    > **注意**:  ストレージ エクスプローラーは現在プレビュー モードであるため、操作の正確なモードが変更される可能性があります。

1. **Storage Explorer (プレビュー)** の 「**BLOB コンテナー**」 の下で、「**振動コンテナ**」 をクリックします。     

    データを表示するには、フォルダの階層を下に移動する必要があります。最初のフォルダには IoT Hub の名前が付けられ、その次はパーティション、それから年、月、日、そして最後の時間になります。 

1. 右側のウィンドウの 「**名前**」 の下で、IoT Hub のフォルダーをダブルクリックし、次に、最新の時間フォルダーを開くまで、ダブルクリックを使用して階層まで移動します。

    時間フォルダ内には、生成された分をとって名前につけてあるファイルが表示されます。

1. Azure Streaming Analytics ジョブを停止するには、ポータル ダッシュボードに戻り、「**vibrationJob**」 を選択します。 

1. 「**Stream Analytics ジョブ**」 ページで、「**停止**」、「**はい**」 の順にクリックします。     

    デバイス アプリから、ルートに沿って、ハブ、ストレージ コンテナーへとアクティビティをトレースしました。大きな進歩です! データの視覚化をすばやく確認する場合は、次のモジュールでこのシナリオのストリーム分析を続行します。

1. 「Visual Studio Code」 ウィンドウに切り替えます。

1. ターミナル コマンド プロンプトで、デバイス シミュレータ アプリを終了するには、**Ctrl-C** キーを押します。

> **重要**: このコースのデータ視覚化モジュールを完了するまで、これらのリソースを削除しないでください。
