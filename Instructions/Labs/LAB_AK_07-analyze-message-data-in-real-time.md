---
lab:
    title: 'ラボ 07:  デバイス メッセージ ルーティング'
    module: 'モジュール 4: メッセージ処理と分析'
---

# デバイス メッセージ ルーティング

## ラボ シナリオ

Contoso の経営陣は、DPS を使用した自動デバイス登録の実装に感銘を受けています。彼らは、製品のパッケージと出荷に関連するビジネス固有の問題に対する IoT ソリューションを検討し始するよう求めています。

Contoso のチーズ製造ビジネスの重要な要素は、顧客へのチーズの梱包と出荷です。コスト効率を最大化するために、Contoso はオンプレミスのパッケージング施設を運営しています。ワークフローは簡単です。パッケージは出荷のために組み立てられ、コンベヤー ベルト システムに置かれると、運ばれて、郵便箱に落とされます。成功の指標は、所定の時間内 (通常は勤務シフト) にコンベア ベルト システムから出発するパッケージの数です。

コンベア ベルト システムは、このプロセスの重要なリンクであり、パッケージが正しく配送されることを確実にするために目視で監視されています。システムには、停止、低速、高速という 3 つのオペレータ制御速度があります。当然、低速で配送される荷物の数は、高速の場合よりも少なくなります。しかし、コンベア ベルト システムの振動レベルも、低速では低くなります。さらに、高い振動レベルでは、システムの消耗が加速することが知られており、パッケージがコンベアから落ちる可能性があります。振動が過剰になった場合は、より深刻な故障を避けるために、コンベア ベルトを停止して検査を行う必要があります。

ソリューションの主な目的は、振動レベルに基づく予防メンテナンスの形態を実装することです。これを使用することで、深刻なシステムの損傷が発生する前に、問題を検出できます。 

> **注意**: **予防保全** (予測メンテナンスとも呼ばれる) は、機器が正常に動作している間に実行されるメンテナンス活動をスケジュールする設備メンテナンスプログラムです。このアプローチの目的は、多くの場合コストのかかる混乱が発生する、予期しない故障を回避することです。

異常な振動レベルを検出することは難しい場合もあります。このため、振動レベルとデータ異常のメジャーに役立つ Azure IoT ソリューションを検討しています。振動センサーは、さまざまな場所でコンベア ベルトに取り付けられ、IoT デバイスを使用して IoT ハブにテレメトリを送信します。IoT ハブは、Azure Stream Analytics と組み込みの機械学習 (ML) モデルを使用して、リアルタイムで振動異常を警告します。また、将来さらに分析を実行できるように、すべてのテレメトリ データをアーカイブする予定です。

単一の IoT デバイスからシミュレートしたテレメトリを使用して、ソリューションのプロトタイプを作成することを決定します。

振動データを現実的な方法でシミュレートするには、エンジニアの 1 人と協力して、振動の原因について少しなりとも理解しておきます。全体の振動レベルに寄与する振動の種類が、さまざまに多いことが判明しました。たとえば、ガイド ホイールが壊れたり、特に重い負荷が不適切にコンベア ベルトにかかったりすると、「力振動」が発生する可能性があります。また、システム設計の限界 (速度や重量など) を超えたときに導入できる「増加する振動」もあります。多少のサポートがあれば、振動データの表現を許容可能なものとして生み出し、異常を生成する、シミュレートされた IoT デバイスのコードを開発することができます。

次のリソースが作成されます。

![ラボ 7 アーキテクチャ](media/LAB_AK_07-architecture.png)

## このラボの内容

このラボでは、次のタスクを完了します。

* ラボの前提条件が満たされていることを確認する (必要な Azure リソースがあること)
* Azure CLI を使用して、Azure IoT Hub とデバイス ID を作成します。
* Visual Studio Code を使用して、デバイスのテレメトリを IoT Hub に送信する C# アプリを作成する
* Azure portal を使用して BLOB ストレージへのメッセージ ルートを作成する
* Azure portal を使用して Azure Stream Analytics ジョブに対する 2 番目のメッセージ ルートを作成する

## ラボの手順

### 演習 1: ラボの前提条件を確認する

このラボでは、次の Azure リソースが利用可能であることを前提としています。

| リソースの種類:  | リソース名 |
| :-- | :-- |
| リソース グループ | rg-az220 |
| IoT Hub | iot-az220-training-{your-id} |
| デバイス ID | sensor-v-3000 |

これらのリソースを利用できない場合は、演習 2 に進む前に、以下の手順に従って、**lab07-setup.azcli** スクリプトを実行する必要があります。スクリプト ファイルは、開発環境構成 (ラボ 3) の一部としてローカルに複製した GitHub リポジトリに含まれています。

**lab07-setup.azcli** スクリプトは、**Bash** シェル環境で実行するように記述されています。Azure Cloud Shell でこれを実行する最も簡単な方法です。

1. ブラウザーを使用して [Azure Shell](https://shell.azure.com/) を開き、このコースで使用している Azure サブスクリプションでログインします。

    Cloud Shell のストレージの設定に関するメッセージが表示された場合は、デフォルトをそのまま使用します。

1. Azure Cloud Shell が **Bash** を使用していることを確認 します。

    「Azure Cloud Shell」 ページの左上隅にあるドロップダウンは、環境を選択するために使用されます。選択されたドロップダウンの値が **Bash** であることを確認します。 

1. Azure Shell ツール バーで、「**ファイルのアップロード/ダウンロード**」 をクリックします (右から 4 番目のボタン)。

1. ドロップダウンで、「**アップロード**」 をクリックします。

1. ファイル選択ダイアログで、開発環境を構成したときにダウンロードした GitHub ラボ ファイルのフォルダーの場所に移動します。

    _ラボ 3: 開発環境の設定_:ZIP ファイルをダウンロードしてコンテンツをローカルに抽出することで、ラボ リソースを含む GitHub リポジトリを複製しました。抽出されたフォルダー構造には、次のフォルダー パスが含まれます。

    * Allfiles
      * ラボ
          * 07-デバイス メッセージ ルーティング
            * セットアップ

    lab07-setup.azcli スクリプト ファイルは、ラボ 7 のセットアップ フォルダーにあります。

1. **lab07-setup.azcli** ファイルを選択し、「**開く**」 をクリックします。   

    ファイルのアップロードが完了すると、通知が表示されます。

1. 正しいファイルが Azure Cloud Shell にアップロードされたことを確認するには、次のコマンドを入力します。

    ```bash
    ls
    ```

    `ls` コマンドを実行すると、現在のディレクトリの内容が一覧表示されます。lab07-setup.azcli ファイルが一覧表示されます。

1. セットアップ スクリプトを含むディレクトリをこのラボ用に作成し、そのディレクトリに移動するには、次の Bash コマンドを入力します。

    ```bash
    mkdir lab7
    mv lab07-setup.azcli lab7
    cd lab7
    ```

1. **lab07-setup.azcli** に実行権限があることを確認するには、次のコマンドを入力します。 

    ```bash
    chmod +x lab07-setup.azcli
    ```

1. Cloud Shell のツール バーで、lab07-setup.azcli ファイルを編集するには、「**エディターを開く**」 (右から 2 番目のボタン - **{ }**) をクリックします。

1. 「**ファイル**」 の一覧で、lab7 フォルダーを展開してスクリプト ファイルを開き、「**lab7**」 をクリックして、「**lab07-setup.azcli**」 をクリックします。     

    エディターは、**lab07-setup.azcli** ファイルの内容を表示します。

1. エディターで、割り当て済みの値 `{YOUR-ID}` と `{YOUR-LOCATION}` を更新します。

    サンプル例として、このコースの最初に作成した一意の ID 、つまり **CAH191211** に `{YOUR-ID}` を設定し、リソースにとって意味のある場所に `{YOUR-LOCATION}` を設定する必要があります。

    ```bash
    #!/bin/bash

    YourID="{YOUR-ID}"
    RGName="rg-az220"
    IoTHubName="AZ-220-HUB-$YourID"

    Location="{YOUR-LOCATION}"
    ```

    > **注意**:  `{YOUR-LOCATION}` 変数は、リージョンの短い名前に設定する必要があります。次のコマンドを入力すると、使用可能な領域とその短い名前 (「**名前**」 列) の一覧を表示できます。
    >
    > ```bash
    > az account list-locations -o Table
    >
    > DisplayName           Latitude    Longitude    Name
    > --------------------  ----------  -----------  ------------------
    > East Asia             22.267      114.188      eastasia
    > Southeast Asia        1.283       103.833      southeastasia
    > Central US            41.5908     -93.6208     centralus
    > East US               37.3719     -79.8164     eastus
    > East US 2             36.6681     -78.3889     eastus2
    > ```

1. エディター画面の右上で、ファイルに加えた変更を保存してエディタを閉じるには、「**..**」 をクリックし、「**エディタを閉じる**」 をクリックします。 

    保存を求められたら、「**保存**」 をクリックすると、エディタが閉じます。 

    > **注意**:  「**CTRL+S**」 を使っていつでも保存でき、 「**CTRL+Q**」 を押してエディターを閉じます。

1. この実習ラボに必要なリソースを作成するには、次のコマンドを入力します。

    ```bash
    ./lab07-setup.azcli
    ```

    このスクリプトの実行には数分かかります。各ステップが完了すると、JSON 出力が表示されます。

    このスクリプトは、まず **rg-az220** という名前のリソース グループ と **AZ-220-ハブ-{YourID}** という名前の IoT ハブを作成します。  既に存在する場合は、対応するメッセージが表示されます。次に、スクリプトにより **sensor-v-3000** の ID を持つデバイスを IoT ハブに追加し、デバイスの接続文字列を表示します。 

1. スクリプトが完了すると、デバイスの接続文字列が表示されることに注意してください。

    接続文字列は「HostName=」で始まります。

1. 接続文字列をテキスト ドキュメントにコピーし、**sensor-v-3000** デバイス用であることに注意します。 

    接続文字列を簡単に見つけることができる場所に保存すると、ラボを続ける準備が整います。

### 演習 2: 振動テレメトリのコードを記述する

Contosoのコンベヤーベルトシステムの監視を自動化し、予測メンテナンスを可能にするには、長期データ分析とリアルタイムデータ分析の両方が必要です。履歴データが存在しないため、最初のステップは、振動データとデータ異常を現実的な方法で模倣するシミュレーションデータを生成することです。 Contosoのエンジニアは、時間の経過に伴う振動をシミュレートするアルゴリズムを開発し、実装するコードクラスにアルゴリズムを組み込みました。エンジニアは、アルゴリズムの調整に必要な将来の更新をサポートすることに同意しました。

最初のプロトタイプフェーズでは、テレメトリデータを生成する単一のIoTデバイスを実装します。振動データに加えて、デバイスはBlobストレージに送信されるいくつかの追加の値（配信されたパッケージ、周囲温度、および同様のメトリック）を作成します。この追加データは、予測メンテナンスのための機械学習モジュールの開発に使用されるデータをシミュレートします。

この演習では、次のことを行います。

* シミュレートされたデバイスプロジェクトを読み込む
* シミュレートされたデバイスの接続文字列を更新し、プロジェクトコードを確認します
* シミュレートされたデバイス接続とテレメトリ通信をテストする
* テレメトリーがIoTハブに到達していることを確認する

#### タスク1：シミュレートされたデバイスプロジェクトを開く

1. Visual Studio Codeを開きます。

1. 上のファイルメニューをクリックし、 **Open...** をクリックします。

1. 07-Device Message Routing フォルダに移動し、**Starter**フォルダ配下のVibrationDeviceを開きます。

1. Visual Studio CodeのEXPLORERペインに次のファイルが表示されます。

    * Program.cs
    * VibrationDevice.csproj
    > 注：必要なアセットをロードするように求められた場合は、今すぐロードできます。

1. Program.csをクリックします。

    ざっと見ると、**VibrationDevice**アプリケーションが前のラボで使用したものと非常に似ていることがわかります。このバージョンのアプリケーションは、対称鍵認証を使用し、テレメトリとロギングメッセージの両方をIoT Hubに送信し、より複雑なセンサー実装を備えています。

1. 新しいターミナルを開きます。

    コマンドプロンプトの一部として示されているディレクトリパスを調べて、正しい場所にいることを確認します。

1. ターミナルコマンドプロンプトで、アプリケーションがエラーなしでビルドされることを確認するには、次のコマンドを入力します。

    ```
    dotnet build
    ```

    出力は次のようになります。

    ```
    ❯ dotnet build
    Microsoft (R) Build Engine version 16.5.0+d4cbfca49 for .NET Core
    Copyright (C) Microsoft Corporation. All rights reserved.

    Restore completed in 39.27 ms for D:\Az220-Code\AllFiles\Labs\07-Device Message Routing\Starter\VibrationDevice\VibrationDevice.csproj.
    VibrationDevice -> D:\Az220-Code\AllFiles\Labs\07-Device Message Routing\Starter\VibrationDevice\bin\Debug\netcoreapp3.1\VibrationDevice.dll

    Build succeeded.
        0 Warning(s)
        0 Error(s)

    Time Elapsed 00:00:01.16
    ```

次のタスクでは、接続文字列を構成し、アプリケーションを確認します。

#### タスク2: 接続を構成してコードを確認する

このタスクで構築するシミュレートされたデバイスアプリは、コンベヤーベルトを監視しているIoTデバイスをシミュレートします。アプリはセンサーの読み取り値をシミュレートし、2秒ごとに振動センサーデータを報告します。

1. Program.csファイルがVisualStudioCodeで開かれていることを確認してください。

1. Programクラスの上部近くで、deviceConnectionString変数の宣言を見つけます。
    ```
    private readonly static string deviceConnectionString = "<your device connection string>";
    ```
1. `<your device connection string>`以前に保存したデバイス接続文字列に置き換えます。

    > 注：これは、このコードに加える必要がある唯一の変更です。

1. ファイルを保存します。

1. プロジェクトの構造を確認してください。

    アプリケーションの構造は、以前にシミュレートしたデバイスプロジェクトの構造と似ていることに注意してください。

    * Using ステートメント
    * 名前空間の定義
        * プログラムクラス - Azure IoT Hubへの接続とテレメトリの送信を担当
        * ConveyorBeltSimulatorクラス - テレメトリを生成するだけでなく、このクラスは実行中のコンベヤーベルトもシミュレートします
        * ConsoleHelper - コンソールへの異なる色のテキストの書き込みをカプセル化する新しいクラス

1. Mainメソッドを確認してください。

    ```
    private static void Main(string[] args)
    {
        ConsoleHelper.WriteColorMessage("Vibration sensor device app.\n", ConsoleColor.Yellow);

        // Connect to the IoT hub using the MQTT protocol.
        deviceClient = DeviceClient.CreateFromConnectionString(deviceConnectionString, TransportType.Mqtt);

        SendDeviceToCloudMessagesAsync();
        Console.ReadLine();
    }
    ```

    deviceConnectionString変数を使用してDeviceClientのインスタンスを作成するのがいかに簡単であるかに注目してください。deviceClientオブジェクトはMainの外部（上記のコードのプログラムレベル）で宣言されているため、グローバルであり、IoTハブと通信するメソッド内で使用できます。

1. SendDeviceToCloudMessagesAsyncメソッドを確認してください。

    ```
    private static async void SendDeviceToCloudMessagesAsync()
    {
        var conveyor = new ConveyorBeltSimulator(intervalInMilliseconds);

        // Simulate the vibration telemetry of a conveyor belt.
        while (true)
        {
            var vibration = conveyor.ReadVibration();

            await CreateTelemetryMessage(conveyor, vibration);

            await CreateLoggingMessage(conveyor, vibration);

            await Task.Delay(intervalInMilliseconds);
        }
    }
    ```

    まず、このメソッドが無限のプログラムループを確立するために使用されていることに注意してください。最初に振動を読み取り、次に定義された時間間隔でメッセージを送信します。

    よく見ると、ConveyorBeltSimulatorクラスを使用して、conveyorという名前のConveyorBeltSimulatorインスタンスが作成されていることがわかります。conveyorオブジェクトは、最初にローカルvibration変数に配置される振動測定値をキャプチャするために使用され、次に、間隔の開始時にキャプチャされたvibration値とともに2つのメッセージ作成メソッドに渡されます。

1. CreateTelemetryMessageメソッドを確認してください。

    ```
    private static async Task CreateTelemetryMessage(ConveyorBeltSimulator conveyor, double vibration)
    {
        var telemetryDataPoint = new
        {
            vibration = vibration,
        };
        var telemetryMessageString = JsonConvert.SerializeObject(telemetryDataPoint);
        var telemetryMessage = new Message(Encoding.ASCII.GetBytes(telemetryMessageString));

        // Add a custom application property to the message. This is used to route the message.
        telemetryMessage.Properties.Add("sensorID", "VSTel");

        // Send an alert if the belt has been stopped for more than five seconds.
        telemetryMessage.Properties.Add("beltAlert", (conveyor.BeltStoppedSeconds > 5) ? "true" : "false");

        Console.WriteLine($"Telemetry data: {telemetryMessageString}");

        // Send the telemetry message.
        await deviceClient.SendEventAsync(telemetryMessage);
        ConsoleHelper.WriteGreenMessage($"Telemetry sent {DateTime.Now.ToShortTimeString()}");
    }
    ```

    以前のラボと同様に、このメソッドはJSONメッセージ文字列を作成し、Messageクラスを使用してメッセージを追加のプロパティとともに送信します。sensorIDプロパティに注意してください。これは、VSTel値をIoTハブで適切にルーティングするために使用されます。また、beltAlertプロパティにも注意してください。これは、コンベヤーベルトが5秒を超えて停止した場合にtrueに設定されます。

    通常どおり、メッセージはデバイスクライアントのSendEventAsyncメソッドを介して送信されます。

1. CreateLoggingMessageメソッドを確認してください。

```
private static async Task CreateLoggingMessage(ConveyorBeltSimulator conveyor, double vibration)
{
    // Create the logging JSON message.
    var loggingDataPoint = new
    {
        vibration = Math.Round(vibration, 2),
        packages = conveyor.PackageCount,
        speed = conveyor.BeltSpeed.ToString(),
        temp = Math.Round(conveyor.Temperature, 2),
    };
    var loggingMessageString = JsonConvert.SerializeObject(loggingDataPoint);
    var loggingMessage = new Message(Encoding.ASCII.GetBytes(loggingMessageString));

    // Add a custom application property to the message. This is used to route the message.
    loggingMessage.Properties.Add("sensorID", "VSLog");

    // Send an alert if the belt has been stopped for more than five seconds.
    loggingMessage.Properties.Add("beltAlert", (conveyor.BeltStoppedSeconds > 5) ? "true" : "false");

    Console.WriteLine($"Log data: {loggingMessageString}");

    // Send the logging message.
    await deviceClient.SendEventAsync(loggingMessage);
    ConsoleHelper.WriteGreenMessage("Log data sent\n");
}
```

このメソッドは、CreateTelemetryMessageメソッドと非常によく似ていることに注意してください。注意すべき重要な項目は次のとおりです。

    * loggingDataPointは、テレメトリオブジェクトよりも多くの情報が含まれています。将来の障害診断アクティビティまたはより詳細な分析を支援するために、ロギングの目的で可能な限り多くの情報を含めるのが一般的です。
    * ロギングメッセージにはsensorIDプロパティが含まれ、今回はVSLogに設定されています。繰り返しになりますが、上記のように、彼はIoTハブでVSLog値を適切にルーティングするために使用されます。

1. 必要に応じて、ConveyorBeltSimulatorクラスとConsoleHelperクラスを確認してください。

    このラボの価値を最大限に引き出すために、これらのクラスのいずれかがどのように機能するかを実際に理解する必要はありませんが、どちらも独自の方法で結果をサポートします。ConveyorBeltSimulatorのクラスには、振動データを生成する速度と関連する状態の数をモデル化する、コンベヤベルトの操作をシミュレートします。ConsoleHelperのクラスは、異なるデータと値を強調するために、コンソールに異なる色のテキストを書き込むために使用されます。

#### タスク3: テレメトリを送信するためのコードをテストする

1. ターミナルコマンドプロンプトで、アプリを実行するには、次のコマンドを入力します。

    ```
    dotnet run
    ```

    このコマンドは、現在のフォルダーにあるProgram.csファイルを実行します。

1. 次のようなコンソール出力が表示されます。

    ```
    Vibration sensor device app.

    Telemetry data: {"vibration":0.0}
    Telemetry sent 10:29 AM
    Log data: {"vibration":0.0,"packages":0,"speed":"stopped","temp":60.22}
    Log data sent

    Telemetry data: {"vibration":0.0}
    Telemetry sent 10:29 AM
    Log data: {"vibration":0.0,"packages":0,"speed":"stopped","temp":59.78}
    Log data sent
    ```

注：ターミナルウィンドウでは、緑色のテキストを使用して正常に動作していることを示し、赤色のテキストを使用して問題が発生していることを示します。エラーメッセージが表示された場合は、まずデバイスの接続文字列を確認してください。

1. 次のタスクのために、このアプリを実行したままにします。

次のタスクに進まない場合は、ターミナルウィンドウでCtrl-Cを入力してアプリを停止できます。dotnet runコマンドを使用して、後で再開できます。

#### タスク4: IoTハブがテレメトリを受信して​​いることを確認する
このタスクでは、Azureポータルを使用して、IoTハブがテレメトリを受信して​​いることを確認します。

1. Azureポータルを開きます。

1. iot-az220-training-{your-id}を開きます。

1. [概要]ペインで、下にスクロールしてメトリックタイルを表示します。

1. 時間範囲を1時間に変更します。

    Device to cloud messagesタイルは、いくつかの現在のアクティビティをプロットします。アクティビティが表示されない場合は、しばらく待ちます。

    デバイスがテレメトリを送り出し、ハブがそれを受信したら、次のステップはメッセージを正しいエンドポイントにルーティングすることです。

#### 演習3: Azure Blob Storageへのメッセージルートを作成する

IoTソリューションでは、データの種類に応じて、またはビジネス上の理由から、受信メッセージデータを複数のエンドポイントの場所に送信する必要があることがよくあります。Azure IoTハブは、メッセージルーティング機能を提供して、受信データをソリューションに必要な場所に転送できるようにします。

私たちのシステムのアーキテクチャでは、データをアーカイブするための保存場所と、より迅速な分析のための場所の2つの宛先にデータを送信する必要があります。

Contosoの振動監視シナリオでは、次の2つのメッセージルートを作成する必要があります。

    * 最初のルートは、データアーカイブ用のAzure Blobストレージの場所になります
    * 2番目のルートは、リアルタイム分析のためのAzure Stream Analyticsジョブへのルートです。

メッセージルートは一度に1つずつ作成してテストする必要があるため、この演習ではストレージルートに焦点を当てます。このルートは「ロギング」ルートと呼ばれ、Azureリソースの作成を数レベル深く掘り下げる必要があります。

メッセージルーティングの重要な機能の1つは、エンドポイントにルーティングする前に着信データをフィルタリングする機能です。SQLクエリとして記述されたフィルタは、特定の条件が満たされた場合にのみ、ルートを介して出力を送信します。

データをフィルタリングする最も簡単な方法の1つは、メッセージのプロパティを評価することです。前の演習でデバイスメッセージにメッセージプロパティを追加したことを思い出してください。追加したコードは次のようになりました。

```
...
telemetryMessage.Properties.Add("sensorID", "VSTel");
...
loggingMessage.Properties.Add("sensorID", "VSLog");
```

これsensorIDで、ルートの基準として使用するSQLクエリをメッセージルート内に埋め込むことができます。この場合、割り当てられた値sensorIDがVSLog（振動センサーログ）の場合、メッセージはストレージアーカイブを対象としています。

この演習では、ロギングルートを作成してテストします。

#### タスク1: メッセージルーティングエンドポイントを定義する

1. あなたのIoTハブがブラウザで開いていることを確認してください。

1. 左側のメニューの[メッセージ]で、[メッセージルーティング]をクリックします。

1. [メッセージルーティング]ペインで、[ルート]タブが選択されていることを確認します。

1. 新しいルートを追加するために、[+追加]をクリックします。

    [ルートの追加]ブレードが表示されます。

1. [ルートブレードの追加]の[名前]で、vibrationLoggingRouteと入力します

1. [+エンドポイントの追加]をクリックし、ドロップダウンリストでストレージをクリックします。

    [ストレージエンドポイントの追加]ブレードが表示されます。

1. [ストレージエンドポイントの追加]の[エンドポイント名]に、vibrationLogEndpointと入力します

1. サブスクリプションに関連付けられているストレージアカウントのリストを表示するには、[コンテナを選択します]をクリックします。

    Azureサブスクリプションに既に存在するストレージアカウントのリストが一覧表示されます。この時点で、既存のストレージアカウントとコンテナを選択できますが、このラボでは新しいものを作成します。

1. ストレージアカウントの作成を開始するには、[+ストレージアカウント]をクリックします。

    [ストレージアカウントの作成]ブレードが表示されます。

1. [ストレージアカウントの作成]ブレードの[名前]で、vibrationstore{your-id}と入力します

    例：vibrationstorecah191211

    > 注：このフィールドには小文字と数字のみを含めることができ、3〜24文字で、一意である必要があります。

1. アカウントの種類ドロップダウンで、StorageV2（汎用V2）を選択します。

1. [パフォーマンス]で、[Standard]が選択されていることを確認します。

    これにより、全体的なパフォーマンスを犠牲にしてコストを抑えることができます。

1. [レプリケーション]で、ローカル冗長ストレージ（LRS）が選択されていることを確認します。

    これにより、ディザスタリカバリのリスク軽減を犠牲にしてコストを抑えることができます。本番環境では、ソリューションでより堅牢なレプリケーション戦略が必要になる場合があります。

1. 場所は、あなたがこのコースではラボのために使用しているという地域を選択します。

1. ストレージアカウントエンドポイントを作成するには、[ OK ]をクリックします。

1. リクエストが検証され、ストレージアカウントの展開が完了するまで待ちます。

    検証と作成には1〜2分かかる場合があります。

    完了すると、[ストレージアカウントの作成]ブレードが閉じ、[ストレージアカウント]ブレードが表示されます。ストレージアカウントブレードは、作成されたばかりのストレージアカウントを表示するように自動更新されている必要があります。

#### タスク2: ストレージアカウントコンテナを定義する

1. vibrationstore{your-id}をクリックします。

    コンテナのブレードが表示されます。これは新しいストレージアカウントであるため、コンテナはリストされていません。

1. コンテナを作成するには、[+コンテナ]をクリックします。

    [新しいコンテナ]ダイアログが表示されます。

1. 名前に、vibrationcontainerと入力します。

    繰り返しになりますが、小文字と数字のみが受け入れられます。

1. [パブリックアクセスレベル]で、[プライベート（匿名アクセスなし）]が選択されていることを確認します。

1. コンテナを作成するには、[作成]をクリックします。

    しばらくすると、コンテナのリース状態が更新され、「Available」と表示されます。

1. ソリューションにこのコンテナーを選択するには、vibrationcontainerをクリックしてから、選択をクリックします。

    [ストレージエンドポイントの追加]ブレードに戻る必要があります。Azure Storageコンテナーが、作成したストレージアカウントとコンテナーのURLに設定されていることに注意してください。

1. [バッチ頻度]ウィンドウフィールドと[チャンクサイズウィンドウ]フィールドは、デフォルト値の100に設定したままにします。

1. [エンコーディング]で、2つのオプションがあり、AVROが選択されていることに注意してください。

    > 注：デフォルトでは、IoT Hubは、メッセージ本文プロパティとメッセージプロパティの両方を持つAvro形式でコンテンツを書き込みます。Avro形式は、他のエンドポイントには使用されません。Avro形式はデータとメッセージの保存には最適ですが、データのクエリに使用するのは困難です。比較すると、JSONまたはCSV形式はデータのクエリにはるかに簡単です。IoT Hubは、AVROだけでなくJSONでのBlobストレージへのデータの書き込みをサポートするようになりました。

1. [ファイル名の形式]フィールドで指定された値を確認してください。

    [ファイル名の形式]フィールドは、ストレージ内のファイルにデータを書き込むために使用されるパターンを指定します。ファイルが作成されると、さまざまなトークンが値に置き換えられます。

1. ブレードの下部にあるストレージエンドポイントを作成するには、[作成]をクリックします。

    検証とその後の作成には少し時間がかかります。完了すると、[ルートの追加]ブレードに戻るはずです。

#### タスク3: ルーティングクエリを定義する

1. [ルートの追加]の[データソース]で、[デバイステレメトリのメッセージ]が選択されていることを確認します。

1. [ルートの有効化]で、[有効化]が選択されていることを確認します。

1. [ルーティングクエリ]で、trueを次のクエリに置き換えます。

    ```
    sensorID = 'VSLog'
    ```

    このクエリにより、sensorIDアプリケーションプロパティがに設定されているメッセージのみVSLogがストレージエンドポイントにルーティングされるようになります。

1. このルートを保存するには、[保存]をクリックします。

    成功メッセージを待ちます。完了すると、ルートがメッセージルーティングペインに表示されます。

1. Azureポータルダッシュボードに戻ります。

#### タスク4: データアーカイブを確認する
1. Visual Studio Codeで作成したデバイスアプリがまだ実行されていることを確認します。

    そうでない場合は、を使用してVisual Studio Codeターミナルで実行しdotnet runます。

1. リソースタイルで、ストレージアカウントブレードを開くには、vibrationstore{your-id}をクリックします。

    リソースタイルにストレージアカウントが表示されない場合は、リソースグループタイルの上部にある[更新]ボタンをクリックし、上記の手順に従ってストレージアカウントを開きます。

1. vibrationstore{your-id}ブレードの左側のメニューで、[ストレージエクスプローラー] （プレビュー）をクリックします。

    ストレージエクスプローラーを使用して、データがストレージアカウントに追加されていることを確認できます。

    > 注：ストレージエクスプローラーは現在プレビューモードであるため、正確な操作モードが変更される場合があります。

1. ストレージエクスプローラー（プレビュー）ペイン、BLOBコンテナを広げ、vibrationcontainerをクリックします。

    データを表示するには、フォルダの階層を下に移動する必要があります。最初のフォルダーは、IoTハブにちなんで名付けられます。

1. [iot-az220-training-{your-id}]をダブルクリックし、ダブルクリックして下の階層に移動します。

    IoTハブフォルダーの下に、パーティションのフォルダーが表示され、次に年、月、日の数値が表示されます。最後のフォルダーは、UTC時間でリストされた時間を表します。Hourフォルダーには、ログメッセージデータを含む多数のブロックブロブが含まれます。

1. タイムスタンプが最も古いデータのBlock Blobをダブルクリックします。

    URLリンクが新しいブラウザタブで開きます。データは読みやすい形式ではありませんが、バイブレーションメッセージとして認識できるはずです。

1. データを含むブラウザータブを閉じてから、Azureポータルダッシュボードに戻ります。

#### 演習4: Azureストリーム分析ジョブのログ記録
この演習では、ログメッセージをBlobストレージに出力するStreamAnalyticsジョブを作成します。次に、Azureポータルのストレージエクスプローラーを使用して、保存されているデータを表示します。

これにより、ルートに次の設定が含まれていることを確認できます。

* 名前-vibrationLoggingRoute
* データソース-DeviceMessages
* ルーティングクエリ-sensorID = 'VSLog'
* エンドポイント- vibrationLogEndpoint
* 有効-真

> 注：このラボでデータをストレージにルーティングし、Azure StreamAnalyticsを介してデータをストレージに送信するのは奇妙に思えるかもしれません。実稼働シナリオでは、両方のパスが長期的に存在することはありません。代わりに、ここで作成している2番目のパスが存在しない可能性があります。ここでは、ラボ環境で、ルーティングが期待どおりに機能していることを検証し、Azure StreamAnalyticsの簡単な実装を示す方法として使用します。

#### タスク1: StreamAnalyticsジョブを作成する

1. Azureポータルメニューで、[+リソースの作成]をクリックします。

1. [新規]ブレードの[Marketplaceを検索]テキストボックスに「stream analytics」と入力し、[Stream Analytics job]をクリックします。

1. 作成をクリックします。

    新しいストリーム解析ジョブペインが表示されます。

1. [新しいStream Analytics ジョブ]の[ジョブ名]で、vibrationJobと入力します。

1. [サブスクリプション]で、ラボで使用しているサブスクリプションを選択します。

1. リソース・グループではrg-az220を選択します。

1. 場所は、あなたがこのラボで使用している地域を選択します。

1. [ホスティング環境]で、[クラウド]が選択されていることを確認します。

    Edgeホスティングについては、コースの後半で説明します。

1. [ストリーミングユニット]で、数を3から1に減らします。

    このラボは3ユニットを必要とせず、これによりコストが削減されます。

1. Stream Analyticsジョブを作成するには、[作成]をクリックします。

1. 展開が成功したというメッセージを待ってから、新しいリソースを開きます。

    > ヒント：新しいリソースに移動するためのメッセージを見逃した場合、またはいつでもリソースを見つける必要がある場合は、[ホーム] / [すべてのリソース]を選択します。リソースのリストに表示されるのに十分なリソース名を入力します。

1. 少し時間を取って、新しいStreamAnalyticsジョブを調べてください。

    入力または出力が表示されていない空のジョブと、スケルトンクエリがあることに注意してください。次のステップは、これらのエントリを入力することです。

1. [ジョブトポロジ]の下の左側のメニューで、[入力]をクリックします。

    [入力]ペインが表示されます。

1. +ストリーム入力の追加をクリックし、IoT Hubを選択します。

    IoT Hub-新規入力ペインが表示されます。

1. 入力エイリアスにvibrationInputと入力します。

1. [サブスクリプションから IoT Hub を選択する]が選択されていることを確認します。

1. [サブスクリプション]で、以前にIoTハブを作成するために使用したサブスクリプションが選択されていることを確認します。

1. [IoTハブ]で、iot-az220-training-{your-id} IoTハブが選択されていることを確認します。

1. [エンドポイント]で、[メッセージング]が選択されていることを確認します。

1. [共有アクセスポリシー名]で、iothubownerが選択されていることを確認します。

1. [コンシューマー]グループで、[$Default]が選択されていることを確認します。

1. [イベントシリアル化形式]で、JSONが選択されていることを確認します。

1. [エンコード]で、UTF-8が選択されていることを確認します。

    一部のフィールドを表示するには、下にスクロールする必要がある場合があります。

1. [イベント圧縮タイプ]で、[なし]が選択されていることを確認します。

1. 新しい入力を保存するには、[保存]をクリックして、入力が作成されるのを待ちます。

    入力リストは、新しい入力を表示するように更新する必要があります。

1. 出力を作成するには、左側のメニューの[ジョブトポロジ]で、[出力]をクリックします。

    [出力]ペインが表示されます。

1. [+追加]をクリックし、BLOBストレージ/ADLS Gen2を選択します。。

1. 出力エイリアスにvibrationOutputを入力します。

1. [サブスクリプションからストレージを選択]が選択されていることを確認します。

1. このラボで使用しているサブスクリプションを選択します。

1. ストレージアカウントでvibrationstore{your-id}を選択します。

    注：ストレージアカウントキーは自動的に入力され、読み取り専用になります。

1. [コンテナ]で、[既存のものを使用]が選択されていること、およびドロップダウンリストから[vibrationcontainer]が選択されていることを確認します。

1. パスパターンは空のままにします。

1. 日付形式と時刻の形式をデフォルトのままにします。

1. [イベントシリアル化形式]で、JSONが選択されていることを確認します。

1. [エンコード]で、UTF-8が選択されていることを確認します。

1. [フォーマット]で、[改行区切り]が選択されていることを確認します。

    > 注：この設定では、各レコードが各行にJSONオブジェクトとして保存され、全体として、無効なJSONレコードであるファイルになります。もう1つのオプションである配列は、ドキュメント全体がJSON配列としてフォーマットされ、各レコードが配列内のアイテムであることを保証します。これにより、ファイル全体を有効なJSONとして解析できます。

1. 最小行数を空白のままにします。

1. [最大時間]で、[時間]と[分]を空白のままにします。

1. 認証モードで接続文字列が選択されていることを確認します。

1. 出力を作成するには、[保存]をクリックして、出力が作成されるのを待ちます。

    出力リストは、新しい出力で更新されます。

1. クエリを編集するには、左側のメニューの[ジョブトポロジ]で、[クエリ]をクリックします。

1. クエリエディタペインで、既存のクエリを以下のクエリに置き換えます。
```
SELECT
    *
INTO
    vibrationOutput
FROM
    vibrationInput
```

1. [クエリの保存]をクリックします。

1. 左側のメニューで、[概要]をクリックします。

#### タスク2: ログルートをテストする
さて、楽しい部分です。デバイスアプリがポンプアウトしているテレメトリは、ルートに沿ってストレージコンテナに送られますか？

1. Visual Studio Codeで作成したデバイスアプリがまだ実行されていることを確認します。

    そうでない場合は、を使用してVisual Studio Codeターミナルでdotnet runを実行します。

1. 概要メニューで[開始]をクリックします。

1. [ジョブの開始]ペインで、[ジョブ出力の開始時刻]を[現在]に設定したままにして、[開始]をクリックします。

    ジョブが開始されるまでに少し時間がかかる場合があります。

1. Azureポータルメニューで、[ダッシュボード]をクリックします。

1. リソースタイルで、vibrationstore{your-id}をクリックします。

    ストレージアカウントが表示されていない場合は、リソースグループタイルの上部にある[更新]ボタンを使用します。

1. ストレージアカウントの[概要]ペインで、[監視]セクションが表示されるまで下にスクロールします。

1. [監視]で、時間範囲を1時間に変更します。

    チャートにアクティビティが表示されます。

1. 左側のメニューで、[Storage Explorer (preview)]をクリックします。

    Storage Explorerを使用して、すべてのデータがストレージアカウントに到達していることをさらに確認できます。

    > 注：ストレージエクスプローラーは現在プレビューモードであるため、正確な操作モードが変更される場合があります。

1. Storage Explorer (preview)のBLOBコンテナー配下のvibrationcontainerをクリックします。

    データを表示するには、フォルダの階層を下に移動する必要があります。最初のフォルダーはIoTHubにちなんで名付けられ、次はパーティション、次に年、月、日、最後に時間になります。

1. 右側のペインの[名前]で、IoTハブのフォルダーをダブルクリックし、最新の時間フォルダーを開くまで、ダブルクリックして階層に移動します。

    時間フォルダー内に、生成された分にちなんで名付けられたファイルが表示されます。これにより、データが意図したとおりに保存場所に到達していることが確認されます。

1. ダッシュボードに戻ります。

1. リソースタイルで、vibrationJobをクリックします。

1. vibrationJobのブレードで停止をクリックします。

    デバイスアプリからハブ、ルート、ストレージコンテナまでのアクティビティを追跡しました。大きな進歩です！データの視覚化をざっと見てみると、次のモジュールでこのシナリオのストリーム分析を続行します。

1. Visual Studio Codeウィンドウに切り替えます。

1. ターミナルコマンドプロンプトで、デバイスシミュレーターアプリを終了するには、CTRL-Cを押します。

    重要：このコースのデータ視覚化モジュールを完了するまで、これらのリソースを削除しないでください。